<!DOCTYPE html><html xmlns="http://www.w3.org/1999/xhtml"><head><title>Introduction to Assembly</title><meta name="generator" content="Hovercraft! 1.0 http://regebro.github.com/hovercraft"></meta><link rel="stylesheet" href="css/hovercraft.css" media="all"></link><link rel="stylesheet" href="css/impressConsole.css" media="all"></link><link rel="stylesheet" href="css/highlight.css" media="all"></link><link rel="stylesheet" href="asm.css" media="screen,projection"></link></head><body class="impress-not-supported"><div id="impress" data-transition-duration="1500"><div class="step step-level-1" step="0" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="0" data-y="0" data-z="0"><h1 id="floating-point-and-simd">Floating Point and SIMD</h1></div><div class="step step-level-1" step="1" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="1600" data-y="0" data-z="0"><h1 id="objectives">Objectives</h1><ul><li>Understand at a basic level how floating point numbers are represented</li><li>Perform basic floating point operations</li><li>Understand and utilize the Single Instruction Multiple Data hardware to perform basic operations</li></ul></div><div class="step step-level-1" step="2" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="3200" data-y="0" data-z="0"><h1 id="x87-the-floating-point-architecture">x87 - The Floating Point Architecture</h1><img src="./images/fpu_outline.jpg"></img></div><div class="step step-level-1" step="3" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="4800" data-y="0" data-z="0"><h1 id="data-registers">Data Registers</h1><ul><li>Can contain any 32 or 64 bit data</li><li>Can't transfer directly from standard registers (e.g., EAX/RAX)</li></ul><img src="./images/fpu_data_regs.jpg"></img></div><div class="step step-level-1" step="4" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="6400" data-y="0" data-z="0"><h1 id="gdb">GDB</h1><p>Display floating point registers:</p><pre class="highlight code bash"><span class="o">(</span>gdb<span class="o">)</span> tui reg float</pre></div><div class="step step-level-1" step="5" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="8000" data-y="0" data-z="0"><h1 id="floating-point-exceptions">Floating Point Exceptions</h1><ul><li>Floating point exceptions are separate from typical interrupts</li><li>They are the only interrupts you can disable from an unprivileged operating context</li><li>The previous instruction pointer (and other contextual information) are stored via special registers</li></ul></div><div class="step step-level-1" step="6" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="9600" data-y="0" data-z="0"><h1 id="floating-point-additional-information">Floating Point - Additional Information</h1><ul><li>Floating point hardware also includes its own FLAGS register</li><li>As mentioned in the previous slide, contextual information is stored in special registers under certain circumstances</li></ul><img src="./images/fpu_outline.jpg"></img></div><div class="step step-level-1" step="7" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="11200" data-y="0" data-z="0"><h1 id="floating-point-encoding">Floating Point Encoding</h1><ul><li>Data encoding is a great deal more complicated for floating point than other types</li><li>Floating point numbers are represented via scientific notation (sort of)</li><li><dl><dt>We can store floats in one of three ways:</dt><dd><ul><li>Single Precision -&gt; which is 32 bits</li><li>Double Precision -&gt; which is 64 bits</li><li>Quad Precision -&gt; which is 128 bits</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="8" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="12800" data-y="0" data-z="0"><h1 id="floating-point-encoding-cont-d">Floating Point Encoding (cont'd)</h1><p>Four parts to the equation:</p><blockquote><ul><li>Significand (also called the mantissa) - This is the decimal representation of our number. A non-zero value will always be in the left-most position</li><li>Radix - The base to multiply by (e.g., 10)</li><li>Exponent - The power to raise the radix to</li></ul></blockquote></div><div class="step step-level-1" step="9" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="14400" data-y="0" data-z="0"><h1 id="floating-point-data-encoding">Floating Point Data Encoding</h1><ul><li>x87 Registers Show the split between different parts (under the hood)</li></ul><p>So if we have a number like 1378.5, and our hardware looks like this:</p><img src="./images/fpu_data_regs.jpg"></img><p>We have:</p><img src="./images/fpu_equation.png"></img></div><div class="step step-level-1" step="10" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="16000" data-y="0" data-z="0"><h1 id="binary-representation">Binary Representation</h1><ol><li>We take the base 2 representation of the number</li><li>We transform the number, such that it can be represented via scientific notation</li><li>The exponent is encoded using a "biased" value, which expedites compare operations</li><li>Since we know that the left-most position of the significand will always be 1, it is dropped for single precision numbers (though it is preserved in doubles).</li></ol></div><div class="step step-level-1" step="11" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="17600" data-y="0" data-z="0"><h1 id="exponent-values">Exponent Values</h1><p>Bias value added to exponent</p><img src="./images/fpu_biased_table.jpg"></img><p>e.g., an exponent of 3 (111 in binary) would get added with 127 (in the case of a single precision float), or 1111111, to get 10000110.</p></div><div class="step step-level-1" step="12" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="19200" data-y="0" data-z="0"><h1 id="special-exponent-values">Special Exponent Values</h1><ul><li><dl><dt>Some values are preserved for special cases in exponent representation</dt><dd><ul><li>00000000 (all 0s) - This value is used to encode +/- infinity</li><li>11111111 (all 1s) - This value is used to indicate NaN (Not a Number)</li></ul></dd></dl></li><li>NaN simply indicates that the floating point encoded value is not valid.</li></ul></div><div class="step step-level-1" step="13" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="20800" data-y="0" data-z="0"><h1 id="working-with-floating-point">Working with Floating Point</h1><ul><li>The floating point registers are treated like a stack</li><li>Values get pushed on (via "load" instructions) and popped off/copied (via "store" instructions)</li></ul></div><div class="step step-level-1" step="14" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="22400" data-y="0" data-z="0"><h1 id="fpu-instruction-set">FPU Instruction Set</h1><p>Basic Operations</p><ul><li><dl><dt>Loads (push)</dt><dd><ul><li>fld - Loads a floating point value from the indicated location, onto the stack</li><li>flid - Loads an integer value, encoding it as a double, onto the stack</li></ul></dd></dl></li><li><dl><dt>Stores</dt><dd><ul><li>fst - Stores the value on the top of the stack at the specified location (either memory or elsewhere in the floating point stack)</li><li>fstp - Performs the same operation as above, but also pops the value off the stack.</li><li>fist - Converts the value at the top of the stack to an integer, and stores it at the destination.</li></ul></dd></dl></li><li>Exchange: fxch - Swaps the contents of the given floating point registers</li></ul></div><div class="step step-level-1" step="15" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="24000" data-y="0" data-z="0"><h1 id="fpu-conditional-move">FPU Conditional Move</h1><p>fcmovcc - Move if: Copies the contents from the requested register in the stack to the top if the condition is satisfied</p><ul><li>b (e.g., fcmovb) - Move if below (if CF is set to 1)</li><li>nb - Move if not below (e.g., CF is 0)</li><li>e - Move if equal (e.g., ZF is 1)</li><li>ne - Move if not equal (ZF is 0)</li><li>be - Move if below or equal (CF is 1 or ZF is 1)</li><li>nbe - Move if not below or equal (CF is 0 and ZF is 0)</li></ul></div><div class="step step-level-1" step="16" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="25600" data-y="0" data-z="0"><h1 id="fpu-arithmetic-operations">FPU Arithmetic Operations</h1><ul><li>fadd/fsub/fmul - Performs the requested operation on the source and destination operands, storing the results in the destination</li><li>fiadd/fisub/fimul - Similar to above, but performs the requested operation on a floating point and integer value</li></ul></div><div class="step step-level-1" step="17" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="27200" data-y="0" data-z="0"><h1 id="lab-11">Lab 11</h1><p>Floating Point Operations</p><ul><li>Copy the Lab11 folder (and its contents)</li><li>Modify the *.nasm file (Each function should have a comment block - lines starting with ';' containing instructions)</li><li>Build and run using the following commands:</li></ul><pre class="highlight code bash">~/Desktop/Lab11 $ cmake . <span class="o">&amp;&amp;</span> cmake --build .
~/Desktop/Lab11 $ ./lab11</pre></div><div class="step step-level-1" step="18" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="28800" data-y="0" data-z="0"><h1 id="single-instruction-multiple-data-simd">Single Instruction, Multiple Data (SIMD)</h1></div><div class="step step-level-1" step="19" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="30400" data-y="0" data-z="0"><h1 id="what-is-simd">What is SIMD?</h1><ul><li>Set of specialized hardware and instructions</li><li>SSE (Streaming SIMD Extensions) is part of this (among others)</li><li>Provide a mechanism for operating on "vectors" of data at a time</li><li>Provides a set of 128-bit registers</li><li>Each can be packed with 4 32-bit "scalar" values</li></ul></div><div class="step step-level-1" step="20" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="32000" data-y="0" data-z="0"><h1 id="simd-hardware">SIMD Hardware</h1><ul><li>x86: 8 SSE registers available, from XMM0 - XMM7</li><li>x64: provides 16 SSE registers, from XMM0 - XMM15</li></ul></div><div class="step step-level-1" step="21" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="33600" data-y="0" data-z="0"><h1 id="why-is-simd-useful">Why is SIMD Useful?</h1><ul><li>Converts a set of operations (ex: 4 multiplications) in a single instruction</li></ul><p>Example: Multiplying two vectors of values -</p><img src="./images/simd_ex.bmp"></img><p>image credit: <a href="http://neilkemp.us/src/sse_tutorial/sse_tutorial.html">http://neilkemp.us/src/sse_tutorial/sse_tutorial.html</a></p></div><div class="step step-level-1" step="22" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="35200" data-y="0" data-z="0"><h1 id="simd-data-movement-aligned-vs-unaligned">SIMD Data Movement - Aligned vs Unaligned</h1><ul><li>Some SIMD instructions differentiate between aligned and unaligned data</li><li>In order to use "aligned" instructions, must guarantee 16 byte alignment</li><li>16 byte is important in this case, because SIMD registers are 16 bytes (128 bits) wide</li></ul></div><div class="step step-level-1" step="23" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="36800" data-y="0" data-z="0"><h1 id="simd-operations-moving-data">SIMD Operations - Moving Data</h1><ul><li><dl><dt>Operations typically operate on vector or scalar values</dt><dd><ul><li>Scalar - 32 bits (single element)</li><li>Vector - All elements of the SIMD register (128 bits)</li></ul></dd></dl></li><li><dl><dt>Moving data in/out:</dt><dd><ul><li>movups - Move 128 bits of data between memory and/or SIMD register(s), unaligned</li><li>movaps - Move 128 bits of data between memory and/or SIMD register(s), aligned</li><li>movhps - Move 64 bits into the high part of a SIMD register</li><li>movlps - Move 64 bits into the low part of a SIMD register</li><li>movss - Move a 32 bit value between memory and/or SIMD register(s)</li></ul></dd></dl></li></ul></div><div class="step step-level-1" step="24" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="38400" data-y="0" data-z="0"><h1 id="simd-moving-around">SIMD: Moving Around</h1><pre class="highlight code nasm"><span class="nf">movups</span> <span class="nv">xmm0</span><span class="p">,</span> <span class="p">[</span><span class="nb">rdi</span><span class="p">]</span>      <span class="c1">; moving 128 bits of data into xmm0</span>
<span class="nf">movss</span> <span class="nv">xmm1</span><span class="p">,</span> <span class="p">[</span><span class="nb">rsi</span><span class="p">]</span>       <span class="c1">; moving 32 bits of data into xmm1</span>
<span class="nf">mov</span> <span class="p">[</span><span class="nb">rdx</span><span class="p">],</span> <span class="nb">eax</span>
<span class="nf">movss</span> <span class="nv">xmm2</span><span class="p">,</span> <span class="p">[</span><span class="nb">rdx</span><span class="p">]</span></pre></div><div class="step step-level-1 instruction-table" step="25" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="40000" data-y="0" data-z="0"><h1 id="simd-arithmetic">SIMD Arithmetic</h1><p>The table below lists arithmetic instructions, both the scalar and vector variations:</p><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>Vector</p></td><td><p>Scalar</p></td><td><p>Description</p></td></tr><tr><td><p>addps</p></td><td><p>addss</p></td><td><p>Adds operands</p></td></tr><tr><td><p>subps</p></td><td><p>subss</p></td><td><p>Subtracts operands</p></td></tr><tr><td><p>mulps</p></td><td><p>mulss</p></td><td><p>Multiplies operands</p></td></tr><tr><td><p>divps</p></td><td><p>divss</p></td><td><p>Divides operands</p></td></tr></tbody></table></div><div class="step step-level-1" step="26" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="41600" data-y="0" data-z="0"><h1 id="id1">SIMD Arithmetic</h1><p>Example use:</p><pre class="highlight code nasm"><span class="nf">movups</span> <span class="nv">xmm0</span><span class="p">,</span> <span class="p">[</span><span class="nb">rdi</span><span class="p">]</span>      <span class="c1">; load first vector</span>
<span class="nf">movups</span> <span class="nv">xmm1</span><span class="p">,</span> <span class="p">[</span><span class="nb">rsi</span><span class="p">]</span>      <span class="c1">; load second vector</span>
<span class="nf">addps</span> <span class="nv">xmm0</span><span class="p">,</span> <span class="nv">xmm1</span>        <span class="c1">; add the two</span>
<span class="nf">movups</span> <span class="p">[</span><span class="nb">rdx</span><span class="p">],</span> <span class="nv">xmm0</span>      <span class="c1">; store the result</span></pre></div><div class="step step-level-1" step="27" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="43200" data-y="0" data-z="0"><h1 id="simd-comparisons">SIMD Comparisons</h1><p>Comparison Operations</p><ul><li><dl><dt>cmp* operation is a bit strange at first</dt><dd><ul><li>Compares a combination of registers/memory</li><li>Stores the result in the first operand</li><li>Third param indicates the type of compare to do (next slide)</li><li>Result stored as 0 if the condition is false, -1 (all 1's) if true</li></ul></dd></dl></li><li>Min and max preserve the values that are greater (or smaller) between operands</li></ul></div><div class="step step-level-1 instruction-table" step="28" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="44800" data-y="0" data-z="0"><h1 id="id2">SIMD Comparisons</h1><p>Cmp's third parameter:</p><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>Number</p></td><td><p>Operation</p></td><td><p>C Equiv</p></td></tr><tr><td><p>0</p></td><td><p>Equal</p></td><td><p>==</p></td></tr><tr><td><p>1</p></td><td><p>Less Than</p></td><td><p>&lt;</p></td></tr><tr><td><p>2</p></td><td><p>Less or equal</p></td><td><p>&lt;=</p></td></tr><tr><td><p>3</p></td><td><p>Unordered</p></td><td><p>n/a</p></td></tr><tr><td><p>4</p></td><td><p>Not Equal</p></td><td><p>!=</p></td></tr><tr><td><p>5</p></td><td><p>Not Less than</p></td><td><p>!(x &lt; y)</p></td></tr><tr><td><p>6</p></td><td><p>Not less or equal</p></td><td><p>!(x &lt;= y)</p></td></tr><tr><td><p>7</p></td><td><p>Ordered</p></td><td><p>n/a</p></td></tr></tbody></table></div><div class="step step-level-1 instruction-table" step="29" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="46400" data-y="0" data-z="0"><h1 id="id3">SIMD Comparisons</h1><p>Operations</p><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>Vector</p></td><td><p>Scalar</p></td><td><p>Description</p></td></tr><tr><td><p>maxps</p></td><td><p>maxss</p></td><td><p>Obtains maximum of operands</p></td></tr><tr><td><p>minps</p></td><td><p>minss</p></td><td><p>Obtains minimum of operands</p></td></tr><tr><td><p>cmpps</p></td><td><p>cmpss</p></td><td><p>Compares operands, all 1's or
0's returned.</p></td></tr></tbody></table></div><div class="step step-level-1" step="30" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="48000" data-y="0" data-z="0"><h1 id="id4">SIMD Comparisons</h1><p>Example:</p><pre class="highlight code nasm"><span class="nf">movups</span> <span class="nv">xmm0</span><span class="p">,</span> <span class="p">[</span><span class="nb">rax</span><span class="p">]</span>
<span class="nf">movups</span> <span class="nv">xmm1</span><span class="p">,</span> <span class="p">[</span><span class="nb">rcx</span><span class="p">]</span>
<span class="nf">cmpps</span> <span class="nv">xmm0</span><span class="p">,</span> <span class="nv">xmm1</span><span class="p">,</span> <span class="mi">4</span>     <span class="c1">; find the values that are not equal</span></pre></div><div class="step step-level-1 instruction-table" step="31" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="49600" data-y="0" data-z="0"><h1 id="simd-bitwise-operations">SIMD Bitwise Operations</h1><table cellpadding="0" cellspacing="0"><tbody><tr><td><p>Vector</p></td><td><p>Description</p></td></tr><tr><td><p>andps</p></td><td><p>Bitwise and of operands</p></td></tr><tr><td><p>orps</p></td><td><p>Bitwise or of operands</p></td></tr><tr><td><p>xorps</p></td><td><p>Bitwise xor of operands</p></td></tr></tbody></table></div><div class="step step-level-1" step="32" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="51200" data-y="0" data-z="0"><h1 id="shuffling-data">Shuffling Data</h1><ul><li>Allows us to rearrange the scalar values within the vector</li><li><dl><dt>Takes three arguments:</dt><dd><ul><li>Source Register</li><li>Destination Register</li><li>A single immediate byte value (imm8) to control how the shuffle takes place</li></ul></dd></dl></li><li>Will often be used with the same register as source/destination (to reorder)</li></ul><pre class="highlight code nasm"><span class="nf">shufps</span> <span class="nv">xmm0</span><span class="p">,</span> <span class="nv">xmm0</span><span class="p">,</span> <span class="mh">0x10</span></pre></div><div class="step step-level-1" step="33" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="52800" data-y="0" data-z="0"><h1 id="shuffling-data-cont-d">Shuffling Data (cont'd)</h1><ul><li>The single byte immediate is broken into 4, 2-bit blocks representing scalar0 - 3</li><li>Each set of bits controls what block from the "source" register gets stored in the "destination"</li></ul></div><div class="step step-level-1" step="34" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="54400" data-y="0" data-z="0"><h1 id="control-bits">Control Bits</h1><ul><li>Bits 1-2: Indicate which "source" block will replace the value in block (or scalar) 0 of the destination register (e.g., 01 would cause the contents of block 1 to be stored in block 0)</li><li>Bits 2-3: Indicate which "source" block will be written to block 1 of the "destination"</li><li>Bits 4-5: Indicate which "source" block will replace the contents of block 2 in the "destination"</li><li>Bits 6-7: Indicate which "source" block will replace the contents of block 3 in the "destination"</li></ul></div><div class="step step-level-1" step="35" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="56000" data-y="0" data-z="0"><h1 id="shuffle-example">Shuffle - Example</h1><img src="./images/sse04.jpg"></img><p>Image credit: <a href="http://www.tommesani.com/index.php/component/content/article/2-simd/62-sse-shuffle.html">http://www.tommesani.com/index.php/component/content/article/2-simd/62-sse-shuffle.html</a></p></div><div class="step step-level-1" step="36" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="57600" data-y="0" data-z="0"><h1 id="id5">GDB</h1><p>Display SIMD registers:</p><pre class="highlight code bash"><span class="o">(</span>gdb<span class="o">)</span> tui reg vector</pre></div><div class="step step-level-1" step="37" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="59200" data-y="0" data-z="0"><h1 id="lab-12">Lab 12</h1><p>SIMD</p><ul><li>Copy the Lab12 folder (and its contents)</li><li>Modify the *.nasm file (Each function should have a comment block - lines starting with ';' containing instructions)</li><li>Build and run using the following commands:</li></ul><pre class="highlight code bash">~/Desktop/Lab12 $ cmake . <span class="o">&amp;&amp;</span> cmake --build .
~/Desktop/Lab12 $ ./lab12</pre></div><div class="step step-level-1" step="38" data-rotate-x="0" data-rotate-y="0" data-rotate-z="0" data-scale="1" data-x="60800" data-y="0" data-z="0"><h1 id="section-review">Section Review</h1><ul><li><dl><dt>Floating Point Architecture</dt><dd><ul><li>Interrupts</li><li>Register Stack</li><li>Flags</li></ul></dd></dl></li><li><dl><dt>SIMD</dt><dd><ul><li>Registers</li><li>Vectors vs Scalars</li></ul></dd></dl></li></ul></div></div><div id="hovercraft-help"><table><tr><th>Space</th><td>Forward</td></tr><tr><th>Right, Down, Page Down</th><td>Next slide</td></tr><tr><th>Left, Up, Page Up</th><td>Previous slide</td></tr><tr><th>P</th><td>Open presenter console</td></tr><tr><th>H</th><td>Toggle this help</td></tr></table></div><script type="text/javascript" src="js/impress.js"></script><script type="text/javascript" src="js/impressConsole.js"></script><script type="text/javascript" src="js/hovercraft.js"></script></body></html>